# # створити декоратор який буде рахувати кількість запущених функцій продекорованих цим декоратором
#
# def make_decorator():
#     count = 0
#
#     def decor(func):
#         def inner():
#             nonlocal count
#             count += 1
#             print(f'count: {count}')
#             func()
#
#         return inner
#
#     return decor
#
# decor = make_decorator()
#
# @decor
# def func1():
#     print('func1')
#
# @decor
# def func2():
#     print('func2')
#
#
# func1()
# func1()
# func2()
# func2()
# func2()

# **********************************************************************************************************************  \/
# # вивести послідовність Фібоначі, кількість вказана в знінній,
# #   наприклад: x = 10 -> 1 1 2 3 5 8 13 21 34 55
# #   (число з послідовності - це сума попередніх двох чисел)
#
# def Fibonacci(n: int) -> str:
#     i = 0
#     mas = [0, 1] + [0] * (n - 1)
#
#     while i + 2 <= n:
#         mas[i + 2] = mas[i] + mas[i + 1]
#         i += 1
#
#     return ' '.join([str(x) for x in mas]);
#
#
# print(Fibonacci(20))
# **********************************************************************************************************************  \/

# # порахувати кількість парних і непарних цифр числа,
# #   наприклад: х = 225688 -> п = 5, н = 1;
# #          х = 33294 -> п = 2, н = 3
#
# def count_even_and_add(n: int) -> str:
#     mas = [int(v) for v in list(str(n))]
#     return f'п = {len([v for v in mas if v % 2 == 0])}, н = {len([v for v in mas if v % 2])}'
#
#
# print(count_even_and_add(225688))
# print(count_even_and_add(33294))
# **********************************************************************************************************************  \/

# # прога, що виводить кількість кожного символа з введеної строки, наприклад:
# # st = 'as 23 fdfdg544'  # введена строка
# #
# # 'a' -> 1  # вивело в консолі
# # 's' -> 1
# # ' ' -> 2
# # '2' -> 1
# # '3' -> 1
# # 'f' -> 2
# # 'd' -> 2
# # 'g' -> 1
# # '5' -> 1
# # '4' -> 2
#
# def count_all_symbols(st: str) -> str:
#     res = dict()
#     sym = list(st)
#
#     for v in sym:
#         if res.setdefault(v):
#             res[v] += 1
#         else:
#             res[v] = 1
#
#     for v in res:
#         print(f'\'{v}\' -> {res[v]}')
#
#
# count_all_symbols('as 23 fdfdg544')
# **********************************************************************************************************************  \/

# # генерируем лист с непарных чисел в порядке возрастания [1,3,5,7,9.....n]
# # задача сделать c него лист листов такого плана:
# #
# # [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]  => [ [1], [3,5], [7,9,11], [13,15,17,19] ]
# # [1, 3, 5, 7, 9, 11] => [[1], [3, 5], [7, 9, 11]]
# # [1, 3, 5, 7, 9]  => [ [1], [3,5], [7,9]]
# # [1, 3, 5, 7, 9, 11, 13]  => [[1], [3, 5], [7, 9, 11], [13]]
#
# def generator_odd_list(mas: list) -> list:
#     mas2, i, v = [], 1, 0
#
#     while v < len(mas):
#         n, mas3 = 0, []
#
#         while n < i and v < len(mas):
#             mas3.append(mas[v])
#             v += 1; n += 1
#         i += 1
#         mas2.append(mas3)
#
#     return mas2
#
#
# print(generator_odd_list([1, 3, 5, 7, 9, 11, 13, 15, 17, 19]))
# print(generator_odd_list([1, 3, 5, 7, 9, 11]))
# print(generator_odd_list([1, 3, 5, 7, 9]))
# print(generator_odd_list([1, 3, 5, 7, 9, 11, 13]))

# **********************************************************************************************************************  \/

# # найти со списка только уникальные числа
# # пример [1,2,3,4,2,5,1] => [ 3, 4, 5 ]
# # методом count пользоваться нельзя
#
# def find_unique(mas:list)->list:
#     res = dict()
#
#     for v in mas:
#         res[v] = -1 if res.setdefault(v) else res[v] = 1
#
#     return [v for v in res if res[v] != -1]
#
#
# print(find_unique([1,2,3,4,2,5,1]))
# print(find_unique([1,2,3,4,2,5,1,1]))

# **********************************************************************************************************************  \/

# # Дан массив целых чисел, найдите тот, который встречается нечетное количество раз.
# # Всегда будет только одно целое число, которое встречается нечетное количество раз
# # [1,2,3,4,5,2,4,1,3] -> 5
#
# def find_one_odd(mas: list) -> int:
#     return [v for v in mas if mas.count(v) % 2 != 0][0]
#
#
# print(find_one_odd([1, 2, 3, 4, 5, 2, 4, 1, 3]))

# **********************************************************************************************************************  \/

# # Знайти анаграму. Перевірити чи слово має в собі такі самі літери як і поеперднє слово
# # ANAGRAM | MGANRAA -> true
# # EXIT | AXET -> false
# # GOOD | DOGO -> true
#
# def anagram(a: str, b: str) -> bool:
#     mas1, mas2 = list(a), list(b)
#     mas1.sort(), mas2.sort()
#     return mas1 == mas2
#
#
# print(anagram('ANAGRAM', 'MGANRAA'))
# print(anagram('EXIT', 'AXET'))
# print(anagram('GOOD', 'DOGO'))

# **********************************************************************************************************************  \/

# # Точная степень двойки
# # Дано натуральное число N.
# # Выведите слово YES, если число N является точной степенью двойки, или слово NO в противном случае.
# # Операцией возведения в степень пользоваться нельзя!
#
# def two(num: int) -> None:
#     trigger = 1
#     while trigger < num:
#         trigger *= 2
#         if trigger == num:
#             print('YES')
#             break;
#     else:
#         print('NO')
#
#
# two(16)
# two(122)
# two(64)

# **********************************************************************************************************************  \/

# # Сумма цифр числа
# # Дано натуральное число N. Вычислите сумму его цифр.
# # При решении этой задачи нельзя использовать строки,
# # списки, массивы ну и циклы, разумеется.
# # Рекурсія)
#
# def sum_of_digits(num: int, sum=0) -> None:
#     sum += num % 10
#     num //= 10
#
#     if num < 1:
#         print(sum)
#         return
#     else:
#         sum_of_digits(num, sum)
#
#
# sum_of_digits(1557)
# sum_of_digits(1857)
# sum_of_digits(1551)

# **********************************************************************************************************************  \/

# # Палиндром
# Дано слово, состоящее только из строчных латинских букв. Проверьте, является ли это слово палиндромом. Выведите YES или NO.
# При решении этой задачи нельзя пользоваться циклами, в решениях на питоне нельзя использовать срезы с шагом, отличным от 1.
#
# def is_palindrome(p: str) -> str:
#     mas1, mas2 = list(p), list(p)
#     mas2.reverse()
#     return 'YES' if mas1 == mas2 else 'NO'
#
#
# print(is_palindrome('tattarrattat'))
# print(is_palindrome('repaper'))
# print(is_palindrome('repapar'))
# print(is_palindrome('level'))

# **********************************************************************************************************************  \/
# # Количество единиц
# # Дана последовательность натуральных чисел  в строке, завершающаяся двумя числами 0 подряд.
# # Определите, сколько раз в этой последовательности встречается число 1. Числа, идущие после двух нулей, необходимо игнорировать.
# # 2176491947586100 -> 3
#
# def count_one(numbers:str)->int:
#     ind = numbers.find('00')
#     return len([v for i, v in enumerate(numbers) if v == '1' and i < ind])
#
# print(count_one('2176491947586100'))
# print(count_one('21764919475861010100'))
# **********************************************************************************************************************  \/

# # Вирівняти багаторівневий масив в однорівневий
# # [1,3, ['Hello, 'Wordd', [9,6,1]], ['oops'], 9] -> [1, 3, 'Hello, 'Wordd', 9, 6, 1, 'oops', 9]
# # flat використовувати заборонено.
#
# def many_to_one(mas: list, res = []) -> list:
#     for v in mas:
#         many_to_one(v) if type(v) == list else res.append(v)
#
#     return res
#
# print(many_to_one([1, 3, ['Hello', 'Wordd', [9, 6, 1]], ['oops'], 9]))
# **********************************************************************************************************************  \/

# # Знайти набільший елемент в масиві за допомогою reduce
# # [1,6,9,0,17,88,4,7] -> 88
#
# import functools
#
# mas = [1,6,9,0,17,88,4,7]
#
# max = functools.reduce(lambda a, b: a if a > b else b, mas)
#
# print(max)

# **********************************************************************************************************************  \/
